;; (set-logic QF_BV)
;; (declare-const x (_ BitVec 2))
;; (declare-const y (_ BitVec 2))

(assume h1 (= x #b01))
(assume h2 (= (bvand x y) #b10))

(step t1 (cl (= x (@pbbterm
                    (! ((_ @int_of 0) x) :named @x0)
                    (! ((_ @int_of 1) x) :named @x1)
        ))) :rule pbblast_pbbvar)

(step t2 (cl (= y (@pbbterm
                    (! ((_ @int_of 0) y) :named @y0)
                    (! ((_ @int_of 1) y) :named @y1)
        ))) :rule pbblast_pbbvar)

(step t3 (cl (= (bvand x y)
                (bvand (@pbbterm @x0 @x1) (@pbbterm @y0 @y1))
        )) :rule cong :premises (t1 t2))

(step t4 (cl (=
            (bvand (@pbbterm @x0 @x1) (@pbbterm @y0 @y1))
            (@pbbterm
                    (! (choice ((z Int)) (and (>= @x0 z) (>= @y0 z) (>= (+ z 1) (+ @x0 @y0)))) :named @r0)
                    (! (choice ((z Int)) (and (>= @x1 z) (>= @y1 z) (>= (+ z 1) (+ @x1 @y1)))) :named @r1)
        ))) :rule pbblast_bvand)

(step t5 (cl (=
            (bvand x y)
            (@pbbterm @r0 @r1)
        )) :rule trans :premises (t3 t4))

(step t6 (cl (= #b10 (@pbbterm 0 1))) :rule pbblast_pbbconst)

(step t7 (cl (= (= (bvand x y) #b10)
                (= (@pbbterm @r0 @r1) (@pbbterm 0 1))
        )) :rule cong :premises (t5 t6))

(step t8 (cl (= (= (@pbbterm @r0 @r1) (@pbbterm 0 1))
                (= (- (+ (* 1 @r0) (* 2 @r1))
                      (+ (* 1 0) (* 2 1)))
                0)
        )) :rule pbblast_bveq)

(step t9 (cl (= (= (bvand x y) #b10) 
                (= (- (+ (* 1 @r0) (* 2 @r1))
                      (+ (* 1 0) (* 2 1)))
                0)
        )) :rule trans :premises (t7 t8))

(step t10 (cl (not (= (bvand x y) #b10))
              (= (- (+ (* 1 @r0) (* 2 @r1)) (+ (* 1 0) (* 2 1))) 0)
          ) :rule equiv1 :premises (t9))

(step t11 (cl (= (- (+ (* 1 @r0) (* 2 @r1))
                    (+ (* 1 0) (* 2 1)))
                0)
        ) :rule resolution :premises (h2 t10))

(step t12 (cl (and
                (>= @x1 @r1)
                (>= @y1 @r1)
                (>= (+ @r1 1) (+ @x1 @y1)))
          ) :rule pbblast_bvand_ith_bit :args (@x1 @y1))

(step t13 (cl (>= @x1 @r1)) :rule and :premises (t12) :args (0))

;; Normalization steps
(step c1 (cl (=
    (= (- (+ (* 1 @r0) (* 2 @r1)) (+ (* 1 0) (* 2 1))) 0)
    (and 
        (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
        (>= (+ (* 1 (- 1 @r0)) (* 2 (- 1 @r1)) (* 1 0) (* 2 1)) 3)
    ;; TODO   cp_normalize
    ))) :rule hole)

(step c2 (cl (not (= (- (+ (* 1 @r0) (* 2 @r1)) (+ (* 1 0) (* 2 1))) 0))
             (and 
                (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
                (>= (+ (* 1 (- 1 @r0)) (* 2 (- 1 @r1)) (* 1 0) (* 2 1)) 3)
             )
    ) :rule equiv1 :premises (c1))

(step c3 (cl (and 
                (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
                (>= (+ (* 1 (- 1 @r0)) (* 2 (- 1 @r1)) (* 1 0) (* 2 1)) 3)
             )
    ) :rule resolution :premises (c2 t11))

(step c4 (cl (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
    ) :rule and :premises (c3) :args (0))

;; Normalization step (2)
(step c5 (cl (= (>= @x1 @r1)
                (>= (+ (* 1 @x1) (* 1 (- 1 @r1))) 1))
    ) :rule cp_normalize)

(step c6 (cl (not (>= @x1 @r1))
             (>= (+ (* 1 @x1) (* 1 (- 1 @r1))) 1)
    ) :rule equiv1 :premises (c5))

(step c7 (cl (>= (+ (* 1 @x1) (* 1 (- 1 @r1))) 1)
    ) :rule resolution :premises (t13 c6))

;; * Use the blasting + equality to get cp constraint
;; TODO: We need to conclude @x1 = 0 from the evidence:
;; * h1 :: x = #b01
;; * t1 :: x = @pbbterm @x0 @x1
;; ? We can get the steps
;; * k1 :: #b01 = @pbbterm 1 0 :rule pbblast_pbbconst
;; * k2 :: @pbbterm @x0 @x1 = @pbbterm 1 0 :rule trans :premises (t1 h1 k1)
;; * k3 :: (and (= @x0 1) (= @x1 0)) :rule pbbterm_equiv :premises k2)
;; * k4 :: (= @x1 0) :rule and :premises k3 :args 1)

(step c9 (cl (>= (* 1 (- 1 @x1)) 1))
    :rule hole :premises (h1 t1))

(step c10 (cl (>= (* 1 1) 1))
    :rule hole :premises (t6))

(step c11 (cl (>= (* 1 (- 1 @r0)) 0))
    :rule cp_literal :args ((- 1 @r0)))

(step c12 (cl (>= (* 1 0) 0))
    :rule cp_literal :args (0))

;; * Starts with CP reasoning
(step c13 (cl (>= (* 1 (- 1 @r1)) 1))
    :rule cp_addition :premises (c7 c9))

(step c14 (cl (>= (* 2 (- 1 @r1)) 2))
    :rule cp_multiplication :premises (c13) :args (2))

(step c15 (cl (>= (+ (* 1 @r0)
                     (* 2 (- 1 1))
                     (* 1 (- 1 0)))
                 3))
    :rule cp_addition :premises (c4 c14))

(step c16 (cl (>= (* 2 1) 2))
    :rule cp_multiplication :premises (c10) :args (2))

(step c17 (cl (>= (+ (* 1 @r0)
                     (* 1 (- 1 0)))
                  3))
    :rule cp_addition :premises (c15 c16))

(step c18 (cl (>= (* 1 (- 1 0)) 2))
    :rule cp_addition :premises (c11 c17))

(step c19 (cl (>= 0 1)) 
    :rule cp_addition :premises (c12 c18))

(step c20 (cl (not (>= 0 1))) :rule la_tautology)

(step c21 (cl) :rule resolution :premises (c19 c20))
