;; (set-logic QF_BV)
;; (declare-const x (_ BitVec 2))
;; (declare-const y (_ BitVec 2))

(assume h1 (= x #b01))

;; ? From h1 you get
;; a : (>= (- 1 @x1) 1)
(step t1 (cl (= #b01 (@pbbterm 1 0)))
    :rule pbblast_pbbconst)

(step t2 (cl (= x (@pbbterm 1 0)))
    :rule trans :premises (h1 t1))

(step t3 (cl (= x (@pbbterm (! ((_ @int_of 0) x) :named @x0)
                            (! ((_ @int_of 1) x) :named @x1)
        ))) :rule pbblast_pbbvar)

(step t4 (cl (= (@pbbterm @x0 @x1)
                (@pbbterm 1 0)))
    :rule trans :premises (t2 t3))

(step t5 (cl (= (= (@pbbterm @x0 @x1) (@pbbterm 1 0))
                (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0)))
    :rule pbblast_bveq)

(step t6 (cl (not (= (@pbbterm @x0 @x1) (@pbbterm 1 0)))
                (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0))
    :rule equiv1 :premises (t5))

(step t7 (cl (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0))
    :rule resolution :premises (t4 t6))

(step t8 (cl (= (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0)
                (and (>= (+ (* 1 @x0) (* 2 @x1)) 1)
                     (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2))))
    :rule cp_normalize)

(step t9 (cl (not (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0))
                (and (>= (+ (* 1 @x0) (* 2 @x1)) 1)
                     (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2)))
    :rule equiv1 :premises (t8))

(step t10 (cl (and (>= (+ (* 1 @x0) (* 2 @x1)) 1)
                   (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2)))
    :rule resolution :premises (t7 t9))

(step t11 (cl (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2))
    :rule and :premises (t10) :args (1))

(step t12 (cl (>= (* 1 @x0) 0))
    :rule cp_literal :args (@x0))

(step t13 (cl (>= (* 2 (- 1 @x1)) 1))
    :rule cp_addition :premises (t11 t12))

(step t14 (cl (>= (* 1 (- 1 @x1)) 1))
    :rule cp_division :premises (t13) :args (2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; t14 : ~x1 >= 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(assume h2 (= (bvand x y) #b10))
;; ? From h2 you get
;; TODO: b (>= (+ @x1 (-1 @r1)) 1)
;; TODO: c (>= @r1 1)

;; TODO: (>= 0 1)   :rule cp_addition :premises (a b c)
