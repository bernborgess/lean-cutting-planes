;; (set-logic QF_BV)
;; (declare-const x (_ BitVec 2))
;; (declare-const y (_ BitVec 2))

(assume h1 (= x #b01))
(assume h2 (= (bvand x y) #b10))

;; ? From h1 you get
;; a : (>= (- 1 @x1) 1)
(step t1 (cl (= #b01 (@pbbterm 1 0)))
    :rule pbblast_pbbconst)

(step t2 (cl (= x (@pbbterm 1 0)))
    :rule trans :premises (h1 t1))

(step t3 (cl (= x (@pbbterm (! ((_ @int_of 0) x) :named @x0)
                            (! ((_ @int_of 1) x) :named @x1)
        ))) :rule pbblast_pbbvar)

(step t4 (cl (= (@pbbterm @x0 @x1)
                (@pbbterm 1 0)))
    :rule trans :premises (t2 t3))

(step t5 (cl (= (= (@pbbterm @x0 @x1) (@pbbterm 1 0))
                (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0)))
    :rule pbblast_bveq)

(step t6 (cl (not (= (@pbbterm @x0 @x1) (@pbbterm 1 0)))
             (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0))
    :rule equiv1 :premises (t5))

(step t7 (cl (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0))
    :rule resolution :premises (t4 t6))

(step t8 (cl (= (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0)
                (and (>= (+ (* 1 @x0) (* 2 @x1)) 1)
                     (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2))))
    :rule cp_normalize)

(step t9 (cl (not (= (- (+ @x0 (* 2 @x1)) (+ 1 (* 2 0))) 0))
             (and (>= (+ (* 1 @x0) (* 2 @x1)) 1)
                  (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2)))
    :rule equiv1 :premises (t8))

(step t10 (cl (and (>= (+ (* 1 @x0) (* 2 @x1)) 1)
                   (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2)))
    :rule resolution :premises (t7 t9))

(step t11 (cl (>= (+ (* 1 (- 1 @x0)) (* 2 (- 1 @x1))) 2))
    :rule and :premises (t10) :args (1))

(step t12 (cl (>= (* 1 @x0) 0))
    :rule cp_literal :args (@x0))

(step t13 (cl (>= (* 2 (- 1 @x1)) 1))
    :rule cp_addition :premises (t11 t12))

(step t14 (cl (>= (* 1 (- 1 @x1)) 1))
    :rule cp_division :premises (t13) :args (2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; t14 : ~x1 >= 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; b (>= (+ @x1 (-1 @r1)) 1)

(step t15 (cl (= (bvand x y)
                 (@pbbterm
                    (! (choice ((z Int)) (and (>= @x0 z) (>= ((_ @int_of 0) y) z) (>= (+ z 1) (+ @x0 ((_ @int_of 0) y))))) :named @r0)
                    (! (choice ((z Int)) (and (>= @x1 z) (>= ((_ @int_of 1) y) z) (>= (+ z 1) (+ @x1 ((_ @int_of 1) y))))) :named @r1)
        ))) :rule pbblast_bvand)

(step t16 (cl (and (>= @x1 @r1)
                   (>= ((_ @int_of 1) y) @r1)
                   (>= (+ @r1 1) (+ @x1 ((_ @int_of 1) y))))
          ) :rule pbblast_bvand_ith_bit :args (@x1 ((_ @int_of 1) y)))

(step t17 (cl (>= @x1 @r1))
    :rule and :premises (t16) :args (0))

(step t18 (cl (= (>= @x1 @r1)
                 (>= (+ @x1 (- 1 @r1)) 1)))
    :rule cp_normalize)

(step t19 (cl (not (>= @x1 @r1))
              (>= (+ @x1 (- 1 @r1)) 1))
    :rule equiv1 :premises (t18))

(step t20 (cl (>= (+ @x1 (- 1 @r1)) 1))
    :rule resolution :premises (t17 t19))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; t20 : x1 + ~r1 >= 1 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; ? From h2 you get
;; TODO: c (>= @r1 1)

;; TODO: (>= 0 1)   :rule cp_addition :premises (a b c)
