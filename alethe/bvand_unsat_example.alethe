;; (set-logic QF_BV)
;; (declare-const x (_ BitVec 2))
;; (declare-const y (_ BitVec 2))

(assume h1 (= x #b01))
(assume h2 (= (bvand x y) #b10))

(step t1 (cl (= x (@pbbterm
                    (! ((_ @int_of 0) x) :named @x0)
                    (! ((_ @int_of 1) x) :named @x1)
        ))) :rule pbblast_pbbvar)

(step t2 (cl (= y (@pbbterm
                    (! ((_ @int_of 0) y) :named @y0)
                    (! ((_ @int_of 1) y) :named @y1)
        ))) :rule pbblast_pbbvar)

(step t3 (cl (= (bvand x y)
                (bvand (@pbbterm @x0 @x1) (@pbbterm @y0 @y1))
        )) :rule cong :premises (t1 t2))

(step t4 (cl (=
            (bvand (@pbbterm @x0 @x1) (@pbbterm @y0 @y1))
            (@pbbterm
                    (! (choice ((z Int)) (and (>= @x0 z) (>= @y0 z) (>= (+ z 1) (+ @x0 @y0)))) :named @r0)
                    (! (choice ((z Int)) (and (>= @x1 z) (>= @y1 z) (>= (+ z 1) (+ @x1 @y1)))) :named @r1)
        ))) :rule pbblast_bvand)

(step t5 (cl (=
            (bvand x y)
            (@pbbterm @r0 @r1)
        )) :rule trans :premises (t3 t4))

(step t6 (cl (= #b10 (@pbbterm 0 1))) :rule pbblast_pbbconst)

(step t7 (cl (= (= (bvand x y) #b10)
                (= (@pbbterm @r0 @r1) (@pbbterm 0 1))
        )) :rule cong :premises (t5 t6))

(step t8 (cl (= (= (@pbbterm @r0 @r1) (@pbbterm 0 1))
                (= (- (+ (* 1 @r0) (* 2 @r1))
                      (+ (* 1 0) (* 2 1)))
                0)
        )) :rule pbblast_bveq)

(step t9 (cl (= (= (bvand x y) #b10) 
                (= (- (+ (* 1 @r0) (* 2 @r1))
                      (+ (* 1 0) (* 2 1)))
                0)
        )) :rule trans :premises (t7 t8))

(step t10 (cl (not (= (bvand x y) #b10))
              (= (- (+ (* 1 @r0) (* 2 @r1)) (+ (* 1 0) (* 2 1))) 0)
          ) :rule equiv1 :premises (t9))

(step t11 (cl (= (- (+ (* 1 @r0) (* 2 @r1))
                    (+ (* 1 0) (* 2 1)))
                0)
        ) :rule resolution :premises (h2 t10))

(step t12 (cl (and
                (>= @x1 @r1)
                (>= @y1 @r1)
                (>= (+ @r1 1) (+ @x1 @y1)))
          ) :rule pbblast_bvand_ith_bit :args (@x1 @y1))

(step t13 (cl (>= @x1 @r1)) :rule and :premises (t12) :args (0))

;; Normalization steps
(step c1 (cl (=
    (= (- (+ (* 1 @r0) (* 2 @r1)) (+ (* 1 0) (* 2 1))) 0)
    (and 
        (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
        (>= (+ (* 1 (- 1 @r0)) (* 2 (- 1 @r1)) (* 1 0) (* 2 1)) 3)
    ))) :rule cp_normalize)

(step c2 (cl (not (= (- (+ (* 1 @r0) (* 2 @r1)) (+ (* 1 0) (* 2 1))) 0))
             (and 
                (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
                (>= (+ (* 1 (- 1 @r0)) (* 2 (- 1 @r1)) (* 1 0) (* 2 1)) 3)
             )
    ) :rule equiv1 :premises (c1))

(step c3 (cl (and 
                (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
                (>= (+ (* 1 (- 1 @r0)) (* 2 (- 1 @r1)) (* 1 0) (* 2 1)) 3)
             )
    ) :rule resolution :premises (c2 t11))

(step c4 (cl (>= (+ (* 1 @r0) (* 2 @r1) (* 1 (- 1 0)) (* 2 (- 1 1))) 3)
    ) :rule and :premises (c3) :args (0))

;; Normalization step (2)
(step c5 (cl (= (>= @x1 @r1)
                (>= (+ (* 1 @x1) (* 1 (- 1 @r1))) 1))
    ) :rule cp_normalize)

(step c6 (cl (not (>= @x1 @r1))
             (>= (+ (* 1 @x1) (* 1 (- 1 @r1))) 1)
    ) :rule equiv1 :premises (c5))

(step c7 (cl (>= (+ (* 1 @x1) (* 1 (- 1 @r1))) 1)
    ) :rule resolution :premises (t13 c6))

;; New way
;; x = pbbterm x0 x1        t1
;; #b01 = pbbterm 1 0       k1
(step k1 (cl (= #b01 (@pbbterm 1 0))) :rule pbblast_pbbconst)

;; x = #b01                 h1
(step p1 (cl (= (= x #b01)
                (= (@pbbterm @x0 @x1) (@pbbterm 1 0))))
    :rule cong :premises (t1 k1))

(step p2 (cl (= (= (@pbbterm @x0 @x1) (@pbbterm 1 0))
                (= (- (+ (* 1 @x0) (* 2 @x1))
                      (+ (* 1 1) (* 2 0)))
                0)
    )) :rule pbblast_bveq)

(step p3 (cl (= (= (- (+ (* 1 @x0) (* 2 @x1))
                      (+ (* 1 1) (* 2 0))) 0)
                (and (>= (+ @x0 (* 2 @x1) (- 1 1) (* 2 (- 1 0))) 3)
                     (>= (+ (- 1 @x0) (* 2 (- 1 @x1)) (* 1 1) (* 2 0)) 3)
                )
    )) :rule cp_normalize)

(step p4 (cl (= (= x #b01)
                (and (>= (+ @x0 (* 2 @x1) (- 1 1) (* 2 (- 1 0))) 3)
                     (>= (+ (- 1 @x0) (* 2 (- 1 @x1)) (* 1 1) (* 2 0)) 3)
                )
    )) :rule trans :premises (p1 p2 p3))

(step p5 (cl (not (= x #b01))
             (and (>= (+ @x0 (* 2 @x1) (- 1 1) (* 2 (- 1 0))) 3)
                  (>= (+ (- 1 @x0) (* 2 (- 1 @x1)) (* 1 1) (* 2 0)) 3)
             )
    ) :rule equiv1 :premises (p4))

(step p6 (cl (and (>= (+ @x0 (* 2 @x1) (- 1 1) (* 2 (- 1 0))) 3)
                  (>= (+ (- 1 @x0) (* 2 (- 1 @x1)) (* 1 1) (* 2 0)) 3)
             )
    ) :rule resolution :premises (h1 p5))

(step p7 (cl (>= (+ (- 1 @x0) (* 2 (- 1 @x1)) (* 1 1) (* 2 0)) 3)
    ) :rule and :premises (p6) :args (1))






;; Old way
(step k2 (cl (= (@pbbterm @x0 @x1) (@pbbterm 1 0))) :rule trans :premises (t1 h1 k1))

;; TODO: We need a way to achieve bitwise equalities from a pbbterm equality
(step k3 (cl (and (= @x0 1) (= @x1 0)))
    ;; ? pbbterm_equiv ?
    :rule hole :premises (k2))

(step k4 (cl (= @x1 0)) :rule and :premises (k3) :args (1))

(step k5 (cl (= (= @x1 0)
                (and (>= @x1 0) (>= (* 1 (- 1 @x1)) 1))
    )) :rule cp_normalize)

(step k6 (cl (not (= @x1 0))
             (and (>= @x1 0) (>= (* 1 (- 1 @x1)) 1))
    ) :rule equiv1 :premises (k5))

(step k7 (cl (and (>= @x1 0) (>= (* 1 (- 1 @x1)) 1))
    ) :rule resolution :premises (k4 k6))

(step c9 (cl (>= (* 1 (- 1 @x1)) 1))
    :rule and :premises (k7) :args (1))

(step c10 (cl (>= (* 1 1) 1)) :rule la_tautology)

(step c11 (cl (>= (* 1 (- 1 @r0)) 0))
    :rule cp_literal :args ((- 1 @r0)))

(step c12 (cl (>= (* 1 0) 0))
    :rule cp_literal :args (0))

;; * Starts with CP reasoning
(step c13 (cl (>= (* 1 (- 1 @r1)) 1))
    :rule cp_addition :premises (c7 c9))

(step c14 (cl (>= (* 2 (- 1 @r1)) 2))
    :rule cp_multiplication :premises (c13) :args (2))

(step c15 (cl (>= (+ (* 1 @r0)
                     (* 2 (- 1 1))
                     (* 1 (- 1 0)))
                 3))
    :rule cp_addition :premises (c4 c14))

(step c16 (cl (>= (* 2 1) 2))
    :rule cp_multiplication :premises (c10) :args (2))

(step c17 (cl (>= (+ (* 1 @r0)
                     (* 1 (- 1 0)))
                  3))
    :rule cp_addition :premises (c15 c16))

(step c18 (cl (>= (* 1 (- 1 0)) 2))
    :rule cp_addition :premises (c11 c17))

(step c19 (cl (>= 0 1)) 
    :rule cp_addition :premises (c12 c18))

(step c20 (cl (not (>= 0 1))) :rule la_tautology)

(step c21 (cl) :rule resolution :premises (c19 c20))
