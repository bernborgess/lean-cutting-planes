\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{algorithmic}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{minted}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Formalizando Bit-blasting com Pseudo-booleanos e verificando no projeto Carcara\\
{\footnotesize Projeto Orientado em Computação II - Pesquisa Científica}
}

\author{\IEEEauthorblockN{Bernardo Borges}
    \IEEEauthorblockA{\textit{Departamento de Ciência da Computação} \\
        \textit{Universidade Federal de Minas Gerais}\\
        Belo Horizonte, Brasil\\
        bernardoborges@dcc.ufmg.br}
}

\maketitle

\begin{abstract}
    Esta pesquisa envolve a aplicação da teoria de Pseudo-booleanos para realizar o procedimento de
    bit-blasting, utilizado para se raciocinar sobre vetores de bits e operações que os envolvem.
\end{abstract}

\begin{IEEEkeywords}
    formal methods, pseudo boolean reasoning, bit blasting, proof checking
\end{IEEEkeywords}

\section{Introdução}
A verificação formal é uma área de pequisa que visa garantir a confiabilidade de sistemas críticos,
como hardware e software, onde erros podem ter consequências graves. Entre as ferramentas utilizadas
nesse contexto, os solucionadores SMT como o cvc5\cite{Cvc5} desempenham um papel central ao permitir
o raciocínio automático sobre diversas estruturas e operações, como as realizadas sobre
vetores de bits, amplamente empregadas em circuitos digitais.
% TODO: Cite some usage of bitvector reasoning for digital circuit verification
Sendo este um processo complexo, técnicas como o bit-blasting são necessárias para dividir o problema
de vetores de bits em termos menores, o que tradicionalmente é feito com valores proposicionais, agora
experimentamos com valores pseudo-booleanos.
Este trabalho explora a integração dessas técnicas, propondo uma extensão ao formato de prova Alethe \cite{Alethe}
e do verificador Carcara \cite{Carcara}, buscando maior confiança e precisão na validação de provas e seus resultados.

\section{Referencial Teórico}
% Capítulo referencial: identificação de trabalhos correlatos, referencial teórico.

\subsection{Aritmética de Bit-Vectors}
A aritmética de Bit-Vectors é amplamente utilizada em áreas como verificação formal,
circuitos digitais e design de hardware, pois permite modelar o comportamento de sistemas
que operam diretamente em representações binárias. Um vetor de bits é uma sequência de bits
(0s e 1s) de comprimento fixo, onde cada bit representa um dígito binário. Operações como soma,
subtração, multiplicação e deslocamento são realizadas diretamente sobre esses vetores,
respeitando restrições como largura fixa e ocorrência de overflow.


\subsection{Bit Blasting}
Uma forma que solucionadores SMT utilizam para raciocinar sobre tais Bit-Vectors é o bit-blasting,
uma representação que utiliza-se de uma variável proposicional para cada bit, o que então pode ser
repassado para outras regras de raciocínio.

O bit-blasting converte operações aritméticas e lógicas em vetores de bits para fórmulas
proposicionais que podem ser resolvidas por solucionadores SAT (Satisfiability). Nesse processo,
cada bit de um vetor é tratado como uma variável proposicional independente, e as operações sobre
os vetores são traduzidas em expressões lógicas que representam o comportamento bit a bit.
Por exemplo, uma operação de soma em vetores de bits pode ser reduzida a uma série de expressões que
modelam o comportamento de somadores completos e meio-somadores, incluindo a propagação de carry
(ou transporte) entre os bits. Assim, uma operação que ocorre em um nível mais abstrato, como
$A + B$, é traduzida em uma série de restrições lógicas que descrevem a interação entre os bits
individuais de $A$ e $B$.


\subsection{Pseudo-Booleanos}
Um formato comumente utilizado para representar expressões booleanas é a Forma Normal Conjuntiva (CNF), que
consiste da conjunção de cláusulas, em que cada cláusula é a disjunção de variáveis ou negação de variáveis\cite{CNF}.
Neste trabalho, usamos uma outra representação para expressões, chamados Pseudo-Booleanos, funções estudadas
desde os anos 1960 na área de pesquisa operacional, em programação inteira. Este formato consiste de um somatório
do produto de um coeficiente por um literal, que é maior ou igual a uma constante natural.
Este formato é exponencialmente mais compacto que o CNF, o que motiva seu uso\cite{PBSolve}.


\subsection{Bit Blasting Pseudo Booleano}
Aproveitando sua estrutura, os Pseudo-Booleanos oferecem uma abordagem alternativa para o
processo de Bit Blasting, permitindo uma representação mais direta da semântica
associada a vetores de bits. Essa semântica está relacionada ao significado numérico ou lógico
dos vetores, que pode ser expressa utilizando coeficientes que ponderam a contribuição de cada
bit em cálculos aritméticos ou restrições lógicas


\subsection{Formato de Prova Alethe}
A corretude é uma preocupação central em solucionadores SMT, dado que eles são amplamente
utilizados em verificação formal, onde a precisão é essencial para garantir que sistemas críticos
funcionem conforme especificado. No entanto, provar a corretude desses solucionadores é um desafio
devido à vasta base de código e às constantes inovações que introduzem alterações frequentes.
Quando um solucionador SMT retorna um resultado `SAT', é relativamente simples verificar de forma
independente se o modelo gerado satisfaz todas as condições impostas. Contudo, no caso de um
resultado `UNSAT', a verificação da corretude requer um \textit{certificado}, ou seja, um registro
detalhado dos passos de raciocínio que levaram à conclusão de insatisfiabilidade.
Nesse sentido, foi desenvolvido o formato Alethe\cite{Alethe}, inspirado na linguagem SMT-LIB, que representa de
forma flexível e padronizada as provas geradas por solucionadores SMT, que podem ser verificados de
forma independente.


\subsection{Verificador de prova Carcara}
Carcara\cite{Carcara} é um verificador de prova desenvolvido em Rust pelo laboratório SMITE da UFMG,
sob a liderança do professor Haniel Barbosa, projetado para verificar certificados de prova no
formato Alethe. Este projeto permite a identificação de erros lógicos nos sistemas que geram
esses certificados, aumentando a confiança nos resultados apresentados.

\section{Contribuições}
% Capítulo de contribuição: descrição organizada das atividades conduzidas pelo aluno.
A contribuição deste trabalho está na definição dos passos tomados para realizar bit-blasting
pseudo booleano para cada operação suportada entre bit-vectors, e então a implementação do
\textit{checker} no projeto Carcara que permite verificar a correta aplicação de tais regras
no formato Alethe.

\section{Definição das Regras em Alethe}
\subsection{Formato das Inequações Pseudo-Booleanas}
Uma inequação pseudo-booleana é uma desigualdade da seguinte forma:
\[
    \sum_i a_i \cdot l_i \geq A
\]
onde $A$ é chamado de \textbf{constante}, $a_i$ são \textbf{coeficientes},
e $l_i$ são \textbf{literais}, que são:
\begin{itemize}
    \item \textbf{literal} simples, um termo \texttt{x};
    \item literal \textbf{negado}, um termo da forma \texttt{(- 1 x)}
\end{itemize}

em que o valor \texttt{x} é uma variável pseudo-booleana, ou seja, ele resolverá para valores
\texttt{0} ou \texttt{1}. Todos esses valores são do tipo \textbf{Int}.

Para formar um somatório, usamos uma lista de termos somados da forma,
\texttt{(+ <T1> <T2> ... 0)} sempre terminando com um \textbf{0}, e cada termo é
\texttt{(* $a_i$ <L1>)}, com um coeficiente e um literal.

\subsection{BitBlasting PseudoBooleano em Alethe}
Similarmente ao bitblasting regular, o cálculo Alethe usa várias famílias de funções auxiliares
para expressar bitblasting pseudo-booleano.
As funções $\textbf{bvsize}$ e $\textbf{bv}_n^i$ funcionam da mesma forma que no bitblasting regular,
ao passo que $\textbf{pbbT}$ e $\textbf{intOf}_m$ introduzem e eliminam a representação em
pseudo-booleanos de um BitVector, que são representados como valores de \textbf{Int}.

A família $\textbf{pbbT}$ consiste em uma função para cada bitvector de \textit{sort} $(\textbf{BitVec}\;n)$:
\[
    \textbf{pbbT}\,:\,\underbrace{\textbf{Int}\,\dots\,\textbf{Int}}_n\;(\textbf{BitVec}\;n).
\]
o que toma uma lista de argumentos pseudo-booleanos e os agrega em um bitvector.

As funções $\textbf{intOf}_m$ são o inverso de $\textbf{pbbT}$. Elas extraem
um bit de um bitvector como um pseudo-booleano. Assim como o símbolo $\textbf{extract}$,
$\textbf{intOf}_m$ é usado como um símbolo indexado. Portanto, para $m \leq n$,
escrevemos \texttt{(\_ @intOf $m$ )}, para denotar funções
\[
    \textbf{intOf}_m : (\textbf{BitVec}\;n) \to \textbf{Int}.
\]
e são definidas como
\[
    \textbf{intOf}_m \langle u_1, \dots, u_n \rangle := u_m.
\]

Todos os outros conceitos não relacionados a essas regras usarão as mesmas definições de bitblasting proposicional.

\subsection{Regras de Predicados}
\subsubsection{\textbf{pbblast\_bveq}}
\noindent\\
Considere os bitvectors \textbf{x} e \textbf{y} de comprimento $n$.
O bitblasting pseudo-booleano de sua igualdade é expresso por:
\begin{align*}
    i. \vartriangleright & (=\ x\ y) \approx A &  & (\text{pbblast\_bveq})
\end{align*}

Em que o termo ``$A$'' é a restrição pseudo-booleana:

\[ \sum_{i=0}^{n-1}{2^i x_{n-i-1}} - \sum_{i=0}^{n-1}{2^i y_{n-i-1}} = 0\]

\subsubsection{\textbf{pbblast\_bvult}}
\noindent\\
A operação `unsigned-less-than', menor ou igual, sem sinal, sobre BitVectors com $n$ bits é
expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvult}\ x\ y) \approx A &  & (\text{pbblast\_bvult})
\end{align*}

Em que o termo ``$A$'' é a restrição pseudo-booleana:

\[
    \sum_{i=0}^{n-1} 2^i\mathbf{y}_{n-i-1} - \sum_{i=0}^{n-1} 2^i\mathbf{x}_{n-i-1} \ge 1.
\]

\subsubsection{\textbf{pbblast\_bvugt}}
\noindent\\
A operação `unsigned-greater-than', maior sem sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvugt}\ x\ y) \approx A &  & (\text{pbblast\_bvugt})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    \sum_{i=0}^{n-1} 2^i\mathbf{x}_{n-i-1} - \sum_{i=0}^{n-1} 2^i\mathbf{y}_{n-i-1} \ge 1.
\]

Alternativamente, em termos de \textbf{pbblast\_bvult}, temos:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvugt}\ x\ y) \approx (\textbf{bvult}\ y\ x) &  & (\text{pbblast\_bvugt})
\end{align*}

\subsubsection{\textbf{pbblast\_bvuge}}
\noindent\\
A operação `unsigned-greater-or-equal', maior ou igual sem sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvuge}\ x\ y) \approx A &  & (\text{pbblast\_bvuge})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    \sum_{i=0}^{n-1} 2^i\mathbf{x}_{n-i-1} - \sum_{i=0}^{n-1} 2^i\mathbf{y}_{n-i-1} \ge 0.
\]

\subsubsection{\textbf{pbblast\_bvule}}
\noindent\\
A operação `unsigned-less-or-equal', menor ou igual sem sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvule}\ x\ y) \approx A &  & (\text{pbblast\_bvule})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    \sum_{i=0}^{n-1} 2^i\mathbf{y}_{n-i-1} - \sum_{i=0}^{n-1} 2^i\mathbf{x}_{n-i-1} \ge 0.
\]

Alternativamente, em termos de \textbf{pbblast\_bvuge}, temos:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvule}\ x\ y) \approx (\textbf{bvuge}\ y\ x) &  & (\text{pbblast\_bvule})
\end{align*}

\subsubsection{\textbf{pbblast\_bvslt}}
\noindent\\
A operação `signed-less-than', menor com sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvslt}\ x\ y) \approx A &  & (\text{pbblast\_bvslt})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    -(2^{n-1})\mathbf{y}_0 + \sum_{i=0}^{n-2} 2^i\mathbf{y}_{n-i-1} + 2^{n-1} \mathbf{x}_{0} - \sum_{i=0}^{n-2} 2^i\mathbf{x}_{n-i-1} \geq 1
\]

\subsubsection{\textbf{pbblast\_bvsgt}}
\noindent\\
A operação `signed-greater-than', maior com sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvsgt}\ x\ y) \approx A &  & (\text{pbblast\_bvsgt})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    -(2^{n-1})\mathbf{x}_0 + \sum_{i=0}^{n-2} 2^i\mathbf{x}_{n-i-1} + 2^{n-1} \mathbf{y}_{0} - \sum_{i=0}^{n-2} 2^i\mathbf{y}_{n-i-1} \geq 1
\]

Alternativamente, em termos de \textbf{pbblast\_bvslt}, temos:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvsgt}\ x\ y) \approx (\textbf{bvslt}\ y\ x) &  & (\text{pbblast\_bvsgt})
\end{align*}

\subsubsection{\textbf{pbblast\_bvsge}}
\noindent\\
A operação `signed-greater-or-equal', maior ou igual com sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvsge}\ x\ y) \approx A &  & (\text{pbblast\_bvsge})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    -(2^{n-1})\mathbf{x}_{0} + \sum_{i=0}^{n-2} 2^i\mathbf{x}_{n-i-1} + 2^{n-1}\mathbf{y}_{0} - \sum_{i=0}^{n-2} 2^i\mathbf{y}_{n-i-1} \geq 0
\]

\subsubsection{\textbf{pbblast\_bvsle}}
\noindent\\
A operação `signed-less-or-equal', menor ou igual com sinal, sobre BitVectors com $n$ bits é expressa por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvsle}\ x\ y) \approx A &  & (\text{pbblast\_bvsle})
\end{align*}

Em que o termo ``$A$'' é verdadeiro se, e somente se:
\[
    -(2^{n-1})\mathbf{y}_{0} + \sum_{i=0}^{n-2} 2^i\mathbf{y}_{n-i-1} + 2^{n-1}\mathbf{x}_{0} - \sum_{i=0}^{n-2} 2^i\mathbf{x}_{n-i-1} \geq 0
\]

Alternativamente, em termos de \textbf{pbblast\_bvsge}, temos:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvsle}\ x\ y) \approx (\textbf{bvsge}\ y\ x) &  & (\text{pbblast\_bvsle})
\end{align*}

\subsection{Regras Aritméticas}
\subsubsection{\textbf{pbblast\_pbbvar}}
\noindent\\
Conversão de um BitVector de $n$ bits para $n$ variáveis pseudo-booleanas introduzidas com \textbf{pbbT}:
\begin{align*}
    i. \vartriangleright &  & x \approx \textbf{pbbT}\; x_1 \dots x_{n+1} &  & (\text{pbblast\_pbbvar})
\end{align*}

\subsubsection{\textbf{pbblast\_pbbconst}}
\noindent\\
Restrições para cada bit do bitvector constante $b$:
\begin{align*}
    i.\vartriangleright & \left(b \approx \textbf{pbbT}r\right) \land \bigwedge_{i=0}^{n-1}{\left(r_i = \textbf{VAL}(b_{n-i-1})\right)}\ (\text{pbblast\_bvsle})
\end{align*}
Em que expandimos \textbf{VAL($b_i$)} em:
\begin{itemize}
    \item $\left(b_i = 0\right)$ se $b_i$ é $0$
    \item $\left(b_i = 1\right)$ se $b_i$ é $1$
\end{itemize}

\subsubsection{\textbf{pbblast\_bvxor}}
\noindent\\
A operação `bvxor' sobre BitVectors com $n$ bits é expressa usando desigualdades PseudoBooleanas por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvxor}\ x\ y) \approx [r_0,\dots,r_1] \land A &  & (\text{pbblast\_bvxor})
\end{align*}
O termo ``$A$'' é a conjunção dessas desigualdades pseudo-booleanas e o termo \textbf{r} representa
o resultado da operação `bvxor' entre \textbf{x} e \textbf{y}, para $0 \le i < n$:

\[ -\textbf{r}_i+\textbf{x}_i+\textbf{y}_i\ge 0 \]
\[ -\textbf{r}_i-\textbf{x}_i-\textbf{y}_i\ge -2 \]
\[ \textbf{r}_i+\textbf{x}_i-\textbf{y}_i\ge 0 \]
\[ \textbf{r}_i-\textbf{x}_i+\textbf{y}_i\ge 0 \]

\subsubsection{\textbf{pbblast\_bvand}}
\noindent\\
A operação `bvand' sobre BitVectors com $n$ bits é expressa usando desigualdades PseudoBooleanas por:
\begin{align*}
    i. \vartriangleright &  & (\textbf{bvand}\ x\ y) \approx [r_0,\dots,r_1] \land A &  & (\text{pbblast\_bvand})
\end{align*}
O termo ``$A$'' é a conjunção dessas desigualdades pseudo-booleanas e o termo \textbf{r} representa
o resultado da operação `bvand' entre \textbf{x} e \textbf{y}, para $0 \le i < n$:

\[ \textbf{x}_i-\textbf{r}_i\ge 0 \]
\[ \textbf{y}_i-\textbf{r}_i\ge 0 \]
\[ \textbf{r}_i-\textbf{x}_i-\textbf{y}_1\ge -1 \]

\section{Verificação das Regras no Carcara}
Com a definição das regras, partimos para a implementação do checker dentro do Carcara.
O primeiro passo é alterações na `ast', a árvore de sintaxe abstrata que faz a leitura de um
arquivo de prova no formato alethe e obtém uma representação da estrutura dos termos envolvidos
naquela regra. Como um parser para esse formato já existe no projeto, temos apenas que estendê-lo
para aceitar os novos símbolos \texttt{pbbT} e \texttt{int\_of}, para introdução e eliminação de
bitvectors por meio de variáveis pseudo-booleanas, nesse caso, \textbf{Int}.

\subsubsection{Extensão do Parser}
\noindent\\
No arquivo \texttt{carcara/src/ast/term.rs} criamos novos construtores:

\begin{minted}[fontsize=\footnotesize]{rust}
pub enum Operator {
    // ...
    BvPBbTerm
}
pub enum ParamOperator {
    // ...
    BvIntOf
}
\end{minted}
Com essa extensão podemos usar `int\_of' e `pbbterm' nos nossos testes e arquivos contendo
estes símbolos serão corretamente lidos pelo sistema.
\subsubsection{Verificação de Regras}
\noindent\\
Podemos dessa forma implementar a verificação de aplicações corretas de cada regra, o que se
dará no arquivo\\ `\texttt{carcara/src/checker/rules/pb\_blasting.rs}',

Vejamos com mais detalhes a verificação da regra \textbf{pbblast\_bveq}:
% TODO: Put code in appendix, just name a pseudo-code here for clarity
\begin{minted}[fontsize=\footnotesize]{rust}
pub fn pbblast_bveq(RuleArgs {
    pool, args, conclusion, .. }: RuleArgs)
    -> RuleResult {
    let ((x, y), ((sum_x, sum_y), _)) = ?;
    let Sort::BitVec(size) = pool.sort(x).?
        unreachable!();
    let size = size.to_usine().unwrap();
    Ok(())
}
\end{minted}

O código completo dessa verificação pode ser encontrado no apêndice, mas o que podemos
analisar aqui é que várias propriedades sintáticas são testadas pelo código:
\begin{itemize}
    \item O número de argumentos aplicados à regra é o esperado?
    \item O tipo dos termos aplicados é apropriado (testado pelo parser)?
          % TODO: mais propriedades aqui
\end{itemize}

Para atender todos estes aspectos é que o Carcara implementa para cada nova construção um
conjunto de testes de unidade, que são executados rapidamente e além de evitar possíveis erros,
servem como documentação viva do comportamento esperado por cada regra. Continuando o exemplo
da regra \textbf{pbblast\_bveq}, vejamos um destes testes:
\begin{minted}[fontsize=\footnotesize]{rust}
mod tests {
  #[test]
  fn pbblast_bveq() {
    test_cases! {
     definitions = "
        (declare-const x1 (_ BitVec 1))
        (declare-const y1 (_ BitVec 1))
        ",
     "Equality on single bits" {
       r#"(step t1 (cl
         (= (= x1 y1)
         (= (-
              (+ (* 1 ((_ int_of 0) x1)) 0)
              (+ (* 1 ((_ int_of 0) y1)) 0)
            ) 0))) :rule pbblast_bveq)"#: true,
      }
    }
  }
}
\end{minted}
Aqui podemos ver um teste que espera \textbf{true}, ou seja, deve ser julgado como uma aplicação
correta da regra \texttt{pbblast\_bveq}.



\section*{Conclusões}
% Capítulo de fechamento: conclusões e relação de trabalhos futuros.
% TODO
% Nós demonstramos a lógica de planos de corte como método correto para trabalhar com pseudo-booleanos.
% Com nossa biblioteca \texttt{lean-cutting-planes} agora podemos utilizar o sistema de tipos de Lean
% para validar com confiança passos dessa lógica. Com a documentação convidamos novos pesquisadores e
% matemáticos a usar os resultados em verificadores.

\begin{thebibliography}{00}
    \bibitem{Cvc5}          H. Barbosa, C. W. Barrett, M. Brain, G. Kremer, H. Lachnitt, M. Mann, A. Mohamed, M. Mohamed, A. Niemetz, A. Nötzli, A. Ozdemir, M. Preiner, A. Reynolds, Y. Sheng, C. Tinelli, Y. Zohar, ``cvc5: A Versatile and Industrial-Strength SMT Solver'', Abril de 2022, Acesso em https://link.springer.com/chapter/10.1007/978-3-030-99524-9\_24.
    \bibitem{Alethe}        H. Barbosa, M. Fleury, P. Fontaine, H. Schurr, ``The Alethe Proof Format - An Evolving Specification and Reference'', Dezembro de 2024, Acesso em https://verit.gitlabpages.uliege.be/alethe/specification.pdf.
    \bibitem{Carcara}       B. Andreotti, H. Lachnitt, H. Barbosa ``Carcara: An Efficient Proof Checker and Elaborator for SMT Proofs in the Alethe Format'', Abril de 2023, Acesso em https://link.springer.com/chapter/10.1007/978-3-031-30823-9\_19.
    \bibitem{CNF}           ``Conjunctive normal form'', Encyclopedia of Mathematics, EMS Press, 2001.
    \bibitem{PBSolve}       J. Nordström, ``Pseudo-Boolean Solving and Optimization'', Fevereiro de 2021.
\end{thebibliography}

\end{document}
