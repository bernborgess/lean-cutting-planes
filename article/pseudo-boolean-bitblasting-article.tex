\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{algorithmic}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[mathletters]{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{minted}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Formalizando Bit-blasting com Pseudo-booleanos e verificando no projeto Carcara\\
{\footnotesize Projeto Orientado em Computação II - Pesquisa Científica}
}

\author{\IEEEauthorblockN{Bernardo Borges}
    \IEEEauthorblockA{\textit{Departamento de Ciência da Computação} \\
        \textit{Universidade Federal de Minas Gerais}\\
        Belo Horizonte, Brasil\\
        bernardoborges@dcc.ufmg.br}
}

\maketitle

\begin{abstract}
    Esta pesquisa envolve a aplicação da teoria de Pseudo-booleanos para realizar o procedimento de
    bit-blasting, utilizado para se raciocinar sobre vetores de bits e operações que os envolvem.
\end{abstract}

\begin{IEEEkeywords}
    formal methods, pseudo boolean reasoning, bit blasting, proof checking
\end{IEEEkeywords}

\section{Introdução}
A verificação formal é uma área de pequisa que visa garantir a confiabilidade de sistemas críticos,
como hardware e software, onde erros podem ter consequências graves. Entre as ferramentas utilizadas
nesse contexto, os solucionadores SMT como o cvc5\cite{Cvc5} desempenham um papel central ao permitir
o raciocínio automático sobre diversas estruturas e operações, como as realizadas sobre
vetores de bits, amplamente empregadas em circuitos digitais.
% TODO: Cite some usage of bitvector reasoning for digital circuit verification
Sendo este um processo complexo, técnicas como o bit-blasting são necessárias para dividir o problema
de vetores de bits em termos menores, o que tradicionalmente é feito com valores proposicionais, agora
experimentamos com valores pseudo-booleanos.
Este trabalho explora a integração dessas técnicas, propondo uma extensão ao formato de prova Alethe \cite{Alethe}
e do verificador Carcara \cite{Carcara}, buscando maior confiança e precisão na validação de provas e seus resultados.

\section{Referencial Teórico}
% Capítulo referencial: identificação de trabalhos correlatos, referencial teórico.

\subsection{Aritmética de Bit-Vectors}
A aritmética de Bit-Vectors é amplamente utilizada em áreas como verificação formal,
circuitos digitais e design de hardware, pois permite modelar o comportamento de sistemas
que operam diretamente em representações binárias. Um vetor de bits é uma sequência de bits
(0s e 1s) de comprimento fixo, onde cada bit representa um dígito binário. Operações como soma,
subtração, multiplicação e deslocamento são realizadas diretamente sobre esses vetores,
respeitando restrições como largura fixa e ocorrência de overflow.


\subsection{Bit Blasting}
Uma forma que solucionadores SMT utilizam para raciocinar sobre tais Bit-Vectors é o bit-blasting,
uma representação que utiliza-se de uma variável proposicional para cada bit, o que então pode ser
repassado para outras regras de raciocínio.

O bit-blasting converte operações aritméticas e lógicas em vetores de bits para fórmulas
proposicionais que podem ser resolvidas por solucionadores SAT (Satisfiability). Nesse processo,
cada bit de um vetor é tratado como uma variável proposicional independente, e as operações sobre
os vetores são traduzidas em expressões lógicas que representam o comportamento bit a bit.
Por exemplo, uma operação de soma em vetores de bits pode ser reduzida a uma série de expressões que
modelam o comportamento de somadores completos e meio-somadores, incluindo a propagação de carry
(ou transporte) entre os bits. Assim, uma operação que ocorre em um nível mais abstrato, como
$A + B$, é traduzida em uma série de restrições lógicas que descrevem a interação entre os bits
individuais de $A$ e $B$.


\subsection{Pseudo-Booleanos}
Um formato comumente utilizado para representar expressões booleanas é a Forma Normal Conjuntiva (CNF), que
consiste da conjunção de cláusulas, em que cada cláusula é a disjunção de variáveis ou negação de variáveis\cite{CNF}.
Neste trabalho, usamos uma outra representação para expressões, chamados Pseudo-Booleanos, funções estudadas
desde os anos 1960 na área de pesquisa operacional, em programação inteira. Este formato consiste de um somatório
do produto de um coeficiente por um literal, que é maior ou igual a uma constante natural.
Este formato é exponencialmente mais compacto que o CNF, o que motiva seu uso\cite{PBSolve}.


\subsection{Bit Blasting Pseudo Booleano}
Aproveitando sua estrutura, os Pseudo-Booleanos oferecem uma abordagem alternativa para o
processo de Bit Blasting, permitindo uma representação mais direta da semântica
associada a vetores de bits. Essa semântica está relacionada ao significado numérico ou lógico
dos vetores, que pode ser expressa utilizando coeficientes que ponderam a contribuição de cada
bit em cálculos aritméticos ou restrições lógicas


\subsection{Formato de Prova Alethe}
A corretude é uma preocupação central em solucionadores SMT, dado que eles são amplamente
utilizados em verificação formal, onde a precisão é essencial para garantir que sistemas críticos
funcionem conforme especificado. No entanto, provar a corretude desses solucionadores é um desafio
devido à vasta base de código e às constantes inovações que introduzem alterações frequentes.
Quando um solucionador SMT retorna um resultado `SAT', é relativamente simples verificar de forma
independente se o modelo gerado satisfaz todas as condições impostas. Contudo, no caso de um
resultado `UNSAT', a verificação da corretude requer um \textit{certificado}, ou seja, um registro
detalhado dos passos de raciocínio que levaram à conclusão de insatisfiabilidade.
Nesse sentido, foi desenvolvido o formato Alethe\cite{Alethe}, inspirado na linguagem SMT-LIB, que representa de
forma flexível e padronizada as provas geradas por solucionadores SMT, que podem ser verificados de
forma independente.


\subsection{Verificador de prova Carcara}
Carcara\cite{Carcara} é um verificador de prova desenvolvido em Rust pelo laboratório SMITE da UFMG,
sob a liderança do professor Haniel Barbosa, projetado para verificar certificados de prova no
formato Alethe. Este projeto permite a identificação de erros lógicos nos sistemas que geram
esses certificados, aumentando a confiança nos resultados apresentados.

\section{Contribuições}
% Capítulo de contribuição: descrição organizada das atividades conduzidas pelo aluno.
A contribuição deste trabalho está na definição dos passos tomados para realizar bit-blasting
pseudo booleano para cada operação suportada entre bit-vectors, e então a implementação do
\textit{checker} no projeto Carcara que permite verificar a correta aplicação de tais regras
no formato Alethe.

% TODO DAQUI PRA FRENTE

\section*{Conclusões}
% Capítulo de fechamento: conclusões e relação de trabalhos futuros.
% TODO
% Nós demonstramos a lógica de planos de corte como método correto para trabalhar com pseudo-booleanos.
% Com nossa biblioteca \texttt{lean-cutting-planes} agora podemos utilizar o sistema de tipos de Lean
% para validar com confiança passos dessa lógica. Com a documentação convidamos novos pesquisadores e
% matemáticos a usar os resultados em verificadores.

\begin{thebibliography}{00}
    \bibitem{Cvc5}          H. Barbosa, C. W. Barrett, M. Brain, G. Kremer, H. Lachnitt, M. Mann, A. Mohamed, M. Mohamed, A. Niemetz, A. Nötzli, A. Ozdemir, M. Preiner, A. Reynolds, Y. Sheng, C. Tinelli, Y. Zohar, ``cvc5: A Versatile and Industrial-Strength SMT Solver'', Abril de 2022, Acesso em https://link.springer.com/chapter/10.1007/978-3-030-99524-9\_24.
    \bibitem{Alethe}        H. Barbosa, M. Fleury, P. Fontaine, H. Schurr, ``The Alethe Proof Format - An Evolving Specification and Reference'', Dezembro de 2024, Acesso em https://verit.gitlabpages.uliege.be/alethe/specification.pdf.
    \bibitem{Carcara}       B. Andreotti, H. Lachnitt, H. Barbosa ``Carcara: An Efficient Proof Checker and Elaborator for SMT Proofs in the Alethe Format'', Abril de 2023, Acesso em https://link.springer.com/chapter/10.1007/978-3-031-30823-9\_19.
    \bibitem{CNF}           ``Conjunctive normal form'', Encyclopedia of Mathematics, EMS Press, 2001.
    \bibitem{PBSolve}       J. Nordström, ``Pseudo-Boolean Solving and Optimization'', Fevereiro de 2021.
\end{thebibliography}

\end{document}
